### 前置: GC中的Reachability

### [GC中的可达性](https://zh.javascript.info/garbage-collection)
+ “reachable”值是指那些以某种方式可访问或可用的值。它们肯定存储在内存中。
  + 有一组基本的固有可访问值，出于显而易见的原因，这些值不能被删除。
  例如：
  + 当前正在执行的函数、其局部变量和参数。
  + 当前嵌套调用链上的其他函数、它们的局部变量和参数。
  + 全局变量。
  + （还有一些其他的内部变量）
  + 这些值被称为root。
+ 任何其他值如果能通过引用或引用链从根节点到达，则被视为可达。
  + 例如，如果全局变量中有一个对象，而该对象有一个属性引用了另一个对象，那么这个对象就被认为是可达的。它所引用的对象也是可达的。

+ 在 JavaScript 引擎中有一个后台进程，称为垃圾回收器。它会监控所有对象，并移除那些已不可达的对象。

### 标记清理
+ 在 JavaScript 中，垃圾回收（GC）的两种主要机制是标记清除（Mark-and-Sweep）和引用计数（Reference Counting）。但现代 JavaScript 引擎主要依赖标记清除算法，而引用计数因其固有缺陷（如循环引用问题）已逐渐被弃用
+ 原理：从根对象（如全局对象、活动函数调用栈等）出发，遍历所有可达(reachable)对象并标记为“存活”，未被标记的对象则被回收。
+ 优势：能处理循环引用（例如两个对象互相引用但无法从根访问），适合复杂对象关系。
+ 现代引擎：V8（Chrome/Node.js）、SpiderMonkey（Firefox）、JavaScriptCore（Safari）等均以标记清除为核心，并辅以分代回收、增量标记等优化策略。


#### [标记清理对循环引用对象的处理](https://javascript.info/garbage-collection#interlinked-objects)
+ 标记清除算法的核心思想是 基于对象可达性（Reachability） 判断是否回收，而非依赖引用次数。其步骤如下：
+ 标记阶段：
  + 从根对象（如全局对象、当前函数调用栈、活动作用域中的变量等）出发，递归遍历所有可达对象。
  + 将这些对象标记为“存活”（例如在内存中设置一个标记位）。

+ 清除阶段：
  + 遍历堆内存中的所有对象。
  + 未被标记的对象（即不可达对象）被判定为垃圾，回收其内存。

#### 标记清理的优化手段

+ 分代收集 - 对象被分为两组：“新对象”和“旧对象”。在典型的代码中，许多对象的生命周期都很短：它们出现，完成任务然后很快消亡，因此跟踪新对象并在必要时清除它们的内存是有意义的。那些存活足够长的对象则成为“旧对象”，并且检查频率较低。

+ 增量收集 - 如果对象数量众多，而我们试图一次性遍历并标记整个对象集，这可能会花费一些时间并导致执行过程中的明显延迟。因此，引擎将现有对象的整个集合拆分为多个部分。然后依次清理这些部分。这样就有许多小的垃圾回收，而不是一次性的全面回收。这需要在它们之间进行一些额外的记录以跟踪变化，但我们得到的是许多小的延迟，而不是一个大的延迟。

+ 空闲时间收集 - 垃圾回收器仅在 CPU 空闲时尝试运行，以减少对执行可能产生的影响。

### 引用计数
  + 原理：跟踪每个对象的引用次数，当引用数为零时立即回收。
  + 缺陷：无法处理循环引用（两个对象互相引用会导致引用数永不为零，内存泄漏）。
  + 历史背景：
    + 旧版 IE（6/7）：DOM 对象曾使用引用计数，导致循环引用时内存泄漏（需手动断开引用）。
    + 早期 JavaScript 引擎：部分实现可能短暂尝试过引用计数，但因缺陷被淘汰。

### 标记清除法是如何解决循环引用的,如何保证遍历算法的安全性

+ 标记清除算法在处理循环引用时不会陷入死循环，核心原因在于它通过 对象可达性标记 和 遍历终止条件 保证了算法的安全性。

---

#### **1. 标记清除如何处理循环引用？**
关键在于 **标记阶段** 的实现方式。标记清除并不是简单地递归遍历所有对象，而是通过 **记录已访问对象** 来避免重复处理。

##### **具体步骤**
1. **初始化**：
   - 所有对象初始标记为 **“未访问”**（例如用 `unreachable` 标记）。
2. **标记阶段**：
   - 从根对象（全局对象、活动调用栈中的变量等）出发，遍历所有直接或间接可达的对象。
   - **遍历方式**：使用 **显式栈（Stack）或队列（Queue）**，而非递归，防止堆栈溢出。
   - **终止条件**：当一个对象被访问并标记为 **“存活”** 后，不会再被重复处理。
3. **清除阶段**：
   - 回收所有未被标记的对象。

##### **循环引用示例**
```javascript
function createCycle() {
  let objA = { name: 'A' };
  let objB = { name: 'B' };
  objA.ref = objB; // A -> B
  objB.ref = objA; // B -> A
}
createCycle(); // objA 和 objB 离开作用域，无法从根访问
```
- **标记阶段**：
  - 从根对象出发，无法到达 `objA` 和 `objB`，因此它们不会被标记为存活。
- **清除阶段**：
  - 两者均被回收，即使它们互相引用。

---

#### **2. 遍历循环引用时为何不会死循环？**
关键在于 **标记机制** 和 **遍历策略**：
1. **标记位（Mark Bit）**：
   - 每个对象有一个标记位（例如 `marked: true/false`）。
   - 当对象被访问时，标记位设为 `true`，后续遍历会跳过已标记对象。
   
2. **显式栈/队列管理**：
   - 遍历时使用栈或队列存储待处理对象，而非递归。
   - 例如，从根对象出发，将直接引用的对象加入队列，依次处理它们的子对象，**处理过的对象不再入队**。

##### **模拟遍历过程**
假设 `objA` 和 `objB` **可以从根访问**（实际场景中通常无法访问）：
1. **根对象**引用 `objA`。
2. 将 `objA` 加入队列，标记为存活。
3. 处理 `objA` 时，发现它引用 `objB`，检查 `objB` 的标记位：
   - 若 `objB` 未标记，将其加入队列并标记。
4. 处理 `objB` 时，发现它引用 `objA`，但 `objA` 已标记，**不再重复处理**。
5. 队列为空，遍历结束。

即使存在循环引用，每个对象**只会被处理一次**，因此不会死循环。

---

#### **3. 引用计数的死循环问题**
引用计数不涉及遍历，它的问题在于 **逻辑缺陷**：
- 如果两个对象互相引用，它们的引用数永远 ≥1，无法归零。
- 即使它们无法从根访问，引用计数也无法回收，导致内存泄漏。

##### **对比示例**
```javascript
// 引用计数场景
let objA = {}; // 引用数 = 1
let objB = {}; // 引用数 = 1
objA.ref = objB; // objB 引用数 = 2
objB.ref = objA; // objA 引用数 = 2

// 解除根引用
objA = null; // objA 引用数 = 1（仍被 objB.ref 引用）
objB = null; // objB 引用数 = 1（仍被 objA.ref 引用）

// 此时 objA 和 objB 的引用数均 ≥1，无法回收！
```

---

#### **4. 标记清除的底层优化**
现代引擎（如 V8）通过 **三色标记法** 进一步优化遍历过程：
- **白色**：未访问对象（初始状态）。
- **灰色**：已访问对象，但子对象未处理完。
- **黑色**：已访问对象，且子对象已处理完。

##### **三色标记流程**
1. 根对象标记为灰色，加入队列。
2. 从队列中取出灰色对象：
   - 遍历其子对象，将未标记的子对象标记为灰色。
   - 自身标记为黑色。
3. 重复步骤 2，直到队列为空。
4. 所有白色对象（不可达）被回收。

此方法确保每个对象**只被处理一次**，彻底避免死循环。

---

#### **总结**
- **标记清除**通过 **可达性分析** 和 **显式遍历控制**，天然解决循环引用问题。
- **不会死循环**：依赖标记位或三色标记法，确保每个对象只处理一次。
- **引用计数**因逻辑缺陷无法处理循环引用，已被现代引擎淘汰。




### [WeakRef](https://javascript.info/weakref-finalizationregistry)


### FinalizationRegistry

